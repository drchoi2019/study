<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Five Elements Block Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans', sans-serif;
            touch-action: manipulation;
        }
        canvas {
            background-color: #F7F3EF;
            display: block;
        }
        .touch-area {
            position: absolute;
            opacity: 0;
            z-index: 10;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .desktop-layout {
            display: flex;
            justify-content: center;
            align-items: start;
            gap: 1rem;
        }
        
        .mobile-layout {
            display: none;
        }
        
        @media (max-width: 768px) {
            .desktop-layout {
                display: none;
            }
            
            .mobile-layout {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                min-height: 100vh;
                padding-top: 2rem;
                gap: 0.5rem;
            }
            
            .mobile-game-area {
                flex: 1;
                display: flex;
                align-items: flex-start;
                justify-content: center;
                width: 100%;
                max-width: 400px;
            }
            
            .mobile-controls {
                display: flex;
                align-items: center;
                justify-content: space-between;
                width: 100%;
                max-width: 400px;
                gap: 1rem;
                padding: 0 0.5rem;
            }
            
            .mobile-next-block {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.25rem;
            }
            
            .mobile-stats {
                display: flex;
                gap: 1.5rem;
            }
            
            .mobile-stat {
                text-align: center;
            }
            
            .mobile-actions {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.25rem;
            }
            
            .touch-areas-container {
                display: block !important;
            }
        }
        
        @media (hover: none) and (pointer: coarse) {
            .touch-areas-container {
                display: block !important;
            }
        }

        .language-toggle {
            cursor: pointer;
            transition: color 0.2s;
        }

        .language-toggle:hover {
            color: #78716c;
        }
    </style>
</head>
<body class="bg-[#F7F3EF] flex flex-col items-center justify-center min-h-screen p-4">
    


    <div class="w-full max-w-md mx-auto">
        
        <!-- Desktop Layout -->
        <div class="desktop-layout">
            <!-- Main Game Area -->
            <div class="w-full max-w-sm">
                <div id="game-container" class="relative w-full aspect-[5/8]">
                    <canvas id="gameCanvas"></canvas>
                    
                    <!-- Touch Areas for Mobile -->
                    <div class="touch-areas-container absolute inset-0 hidden">
                        <!-- Left area for move left -->
                        <div id="leftTouchArea" class="touch-area" style="top: 25%; left: 0; width: 50%; height: 75%;"></div>
                        <!-- Right area for move right -->
                        <div id="rightTouchArea" class="touch-area" style="top: 25%; right: 0; width: 50%; height: 75%;"></div>
                    </div>
                    
                    <div id="pauseScreen" class="absolute inset-0 bg-[#F7F3EF]/80 flex-col items-center justify-center rounded-lg hidden">
                        <h2 class="text-5xl font-bold text-stone-500" data-translate="paused">Paused</h2>
                    </div>

                    <div id="helpModal" class="absolute inset-0 flex-col items-center justify-center rounded-lg hidden">
                        <div class="bg-[#F7F3EF] p-6 rounded-lg shadow-lg text-stone-700 max-w-xs mx-4 border-2 border-stone-300">
                            <h3 class="text-2xl font-bold mb-4 text-center" data-translate="how_to_play">How to Play</h3>
                            <ul class="space-y-2 text-sm">
                                <li class="flex items-start"><span class="mr-2">1.</span><span data-translate="help_move">Touch left/right side to move the block.</span></li>
                                <li class="flex items-start"><span class="mr-2">2.</span><span data-translate="help_drop">Two-finger touch anywhere for fast drop.</span></li>
                                <li class="flex items-start"><span class="mr-2">3.</span><span data-translate="help_match">Match 3+ adjacent blocks of the same element to clear them.</span></li>
                                <li class="flex items-start"><span class="mr-2">4.</span><span data-translate="help_bonus">Clearing 4+ blocks at once gives double points.</span></li>
                            </ul>
                            <button id="closeHelpButton" class="mt-6 w-full px-6 py-2 bg-stone-400 hover:bg-stone-500 text-white rounded-lg font-bold text-lg transition" data-translate="close">Close</button>
                        </div>
                    </div>

                    <div id="levelUpScreen" class="absolute inset-0 bg-[#F7F3EF]/90 flex-col items-center justify-center rounded-lg hidden">
                        <h2 id="levelUpTitle" class="text-4xl font-bold text-stone-500" data-translate="level_up">Level Up!</h2>
                        <p id="levelUpSubtitle" class="text-lg mt-2 text-stone-600">Stage 2 Start</p>
                        <button id="continueButton" class="mt-6 px-6 py-3 bg-stone-400 hover:bg-stone-500 text-white rounded-lg font-bold text-xl transition-transform transform hover:scale-105" data-translate="continue">
                            Continue
                        </button>
                    </div>

                    <div id="gameOverScreen" class="absolute inset-0 bg-[#F7F3EF]/90 flex-col items-center justify-center rounded-lg hidden">
                        <h2 class="text-4xl font-bold text-stone-500" data-translate="game_over">Game Over</h2>
                        <p class="text-lg mt-2 text-stone-600"><span data-translate="score">Score</span>: <span id="finalScore">0</span></p>
                        <button id="restartButton" class="mt-6 px-6 py-3 bg-stone-400 hover:bg-stone-500 text-white rounded-lg font-bold text-xl transition-transform transform hover:scale-105" data-translate="restart">
                            Restart
                        </button>
                    </div>
                </div>
            </div>

            <!-- Desktop Sidebar -->
            <div class="w-24 flex-shrink-0 pt-2">
                <div class="text-left text-stone-600">
                    <canvas id="nextBlockCanvas" class="rounded-lg"></canvas>
                    <div class="mt-4">
                        <div class="text-base font-bold" data-translate="score">Score</div>
                        <div id="score" class="text-lg">0</div>
                        <div class="text-base font-bold mt-2" data-translate="level">Level</div>
                        <div id="level" class="text-lg">1</div>
                        <div id="help-button" class="text-base font-bold mt-2 cursor-pointer hover:text-stone-800" data-translate="help">
                                Help
                        </div>
                    </div>
                    <div class="mt-4 flex items-center gap-2">
                        <canvas id="pixelPersonCanvas"></canvas>
                        <div id="language-toggle" class="text-base font-bold cursor-pointer language-toggle text-stone-600">
                            Kor
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Mobile Layout -->
        <div class="mobile-layout">
            <!-- Mobile Controls at Top -->
            <div class="mobile-controls">
                <div class="mobile-next-block">
                    <div class="text-xs font-bold text-stone-600" data-translate="next">Next</div>
                    <canvas id="mobileNextBlockCanvas" class="rounded"></canvas>
                </div>
                
                <div class="mobile-stats">
                    <div class="mobile-stat">
                        <div class="text-xs font-bold text-stone-600" data-translate="score">Score</div>
                        <div id="mobileScore" class="text-lg font-bold text-stone-700">0</div>
                    </div>
                    <div class="mobile-stat">
                        <div class="text-xs font-bold text-stone-600" data-translate="level">Level</div>
                        <div id="mobileLevel" class="text-lg font-bold text-stone-700">1</div>
                    </div>
                </div>
                
                <div class="mobile-actions">
                    <div class="flex items-center gap-1">
                        <canvas id="mobilePixelPersonCanvas"></canvas>
                        <div id="mobile-language-toggle" class="text-xs font-bold text-stone-600 cursor-pointer language-toggle">
                            Kor
                        </div>
                    </div>
                    <div id="mobile-help-button" class="text-xs font-bold text-stone-600 cursor-pointer hover:text-stone-800" data-translate="help">
                        Help
                    </div>
                </div>
            </div>

            <!-- Mobile Game Area -->
            <div class="mobile-game-area">
                <div id="mobile-game-container" class="relative w-full aspect-[5/8] max-w-sm">
                    <canvas id="mobileGameCanvas"></canvas>
                    
                    <!-- Touch Areas for Mobile -->
                    <div class="touch-areas-container absolute inset-0">
                        <!-- Left area for move left -->
                        <div id="mobileLeftTouchArea" class="touch-area" style="top: 25%; left: 0; width: 50%; height: 75%;"></div>
                        <!-- Right area for move right -->
                        <div id="mobileRightTouchArea" class="touch-area" style="top: 25%; right: 0; width: 50%; height: 75%;"></div>
                    </div>
                    
                    <!-- Mobile versions of all overlays with same structure as desktop but prefixed with mobile -->
                    <div id="mobilePauseScreen" class="absolute inset-0 bg-[#F7F3EF]/80 flex-col items-center justify-center rounded-lg hidden">
                        <h2 class="text-4xl font-bold text-stone-500" data-translate="paused">Paused</h2>
                    </div>

                    <div id="mobileHelpModal" class="absolute inset-0 flex-col items-center justify-center rounded-lg hidden">
                        <div class="bg-[#F7F3EF] p-6 rounded-lg shadow-lg text-stone-700 max-w-xs mx-4 border-2 border-stone-300">
                            <h3 class="text-2xl font-bold mb-4 text-center" data-translate="how_to_play">How to Play</h3>
                            <ul class="space-y-2 text-sm">
                                <li class="flex items-start"><span class="mr-2">1.</span><span data-translate="help_move">Touch left/right side to move the block.</span></li>
                                <li class="flex items-start"><span class="mr-2">2.</span><span data-translate="help_drop">Two-finger touch anywhere for fast drop.</span></li>
                                <li class="flex items-start"><span class="mr-2">3.</span><span data-translate="help_match">Match 3+ adjacent blocks of the same element to clear them.</span></li>
                                <li class="flex items-start"><span class="mr-2">4.</span><span data-translate="help_bonus">Clearing 4+ blocks at once gives double points.</span></li>
                            </ul>
                            <button id="mobileCloseHelpButton" class="mt-6 w-full px-6 py-2 bg-stone-400 hover:bg-stone-500 text-white rounded-lg font-bold text-lg transition" data-translate="close">Close</button>
                        </div>
                    </div>

                    <div id="mobileLevelUpScreen" class="absolute inset-0 bg-[#F7F3EF]/90 flex-col items-center justify-center rounded-lg hidden">
                        <h2 id="mobileLevelUpTitle" class="text-4xl font-bold text-stone-500" data-translate="level_up">Level Up!</h2>
                        <p id="mobileLevelUpSubtitle" class="text-lg mt-2 text-stone-600">Stage 2 Start</p>
                        <button id="mobileContinueButton" class="mt-6 px-6 py-3 bg-stone-400 hover:bg-stone-500 text-white rounded-lg font-bold text-xl transition-transform transform hover:scale-105" data-translate="continue">
                            Continue
                        </button>
                    </div>

                    <div id="mobileGameOverScreen" class="absolute inset-0 bg-[#F7F3EF]/90 flex-col items-center justify-center rounded-lg hidden">
                        <h2 class="text-4xl font-bold text-stone-500" data-translate="game_over">Game Over</h2>
                        <p class="text-lg mt-2 text-stone-600"><span data-translate="score">Score</span>: <span id="mobileFinalScore">0</span></p>
                        <button id="mobileRestartButton" class="mt-6 px-6 py-3 bg-stone-400 hover:bg-stone-500 text-white rounded-lg font-bold text-xl transition-transform transform hover:scale-105" data-translate="restart">
                            Restart
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center py-8 mt-12 text-sm text-gray-500 desktop-layout">
        <p>&copy; 2024 Hyungsuk Choi. All Rights Reserved.</p>
    </footer>

    <script>
        // Language system
        const LANGUAGES = {
            en: {
                // UI translations
                paused: "Paused",
                how_to_play: "How to Play",
                help_move: "Touch left/right side to move the block.",
                help_drop: "Two-finger touch anywhere for fast drop.",
                help_match: "Match 3+ adjacent blocks of the same element to clear them.",
                help_bonus: "Clearing 4+ blocks at once gives double points.",
                close: "Close",
                level_up: "Level Up!",
                continue: "Continue",
                game_over: "Game Over",
                score: "Score",
                level: "Level",
                help: "Help",
                next: "Next",
                restart: "Restart",
                stage: "Stage",
                speed_up: "Speed Up!",
                // Game data
                levels: [
                    { // Level 1
                        'Wood': { core: 'Wood', items: ['Wood', 'Eyes', 'Liver', 'Wind'] },
                        'Fire': { core: 'Fire', items: ['Fire', 'Tongue', 'Heart', 'Heat'] },
                        'Earth': { core: 'Earth', items: ['Earth', 'Mouth', 'Spleen', 'Damp'] },
                        'Metal': { core: 'Metal', items: ['Metal', 'Nose', 'Lung', 'Dry'] },
                        'Water': { core: 'Water', items: ['Water', 'Ears', 'Kidney', 'Cold'] }
                    },
                    { // Level 2
                        'Wood': { core: 'Wood', items: ['Anger', 'Blue', 'Gall'] },
                        'Fire': { core: 'Fire', items: ['Joy', 'Red', 'Small\nIntestine'] },
                        'Earth': { core: 'Earth', items: ['Thought', 'Yellow', 'Stomach'] },
                        'Metal': { core: 'Metal', items: ['Grief', 'White', 'Large\nIntestine'] },
                        'Water': { core: 'Water', items: ['Fear', 'Black', 'Bladder'] }
                    },
                    { // Level 3
                        'Wood': { core: 'Wood', items: ['Spring', 'Nails', 'Sour', 'East'] },
                        'Fire': { core: 'Fire', items: ['Summer', 'Face', 'Bitter', 'South'] },
                        'Earth': { core: 'Earth', items: ['Lips', 'Sweet'] },
                        'Metal': { core: 'Metal', items: ['Autumn', 'Body\nHair', 'Spicy', 'West'] },
                        'Water': { core: 'Water', items: ['Winter', 'Hair', 'Salty', 'North'] }
                    }
                ]
            },
            ko: {
                // UI translations
                paused: "일시정지",
                how_to_play: "게임 방법",
                help_move: "좌우를 터치하여 블록을 이동하세요.",
                help_drop: "두 손가락 터치로 빠르게 떨어뜨리기.",
                help_match: "같은 원소의 인접한 블록 3개 이상을 맞춰 제거하세요.",
                help_bonus: "4개 이상 한 번에 제거하면 보너스 점수!",
                close: "닫기",
                level_up: "레벨 업!",
                continue: "계속하기",
                game_over: "게임 오버",
                score: "점수",
                level: "레벨",
                help: "도움말",
                next: "다음",
                restart: "다시 시작",
                stage: "단계",
                speed_up: "속도 증가!",
                // Game data
                levels: [
                    { // Level 1
                        'Wood': { core: 'Wood', items: ['나무', '눈', '간장', '바람'] },
                        'Fire': { core: 'Fire', items: ['불', '혀', '심장', '열'] },
                        'Earth': { core: 'Earth', items: ['땅', '입', '비장', '습'] },
                        'Metal': { core: 'Metal', items: ['쇠', '코', '폐장', '건조'] },
                        'Water': { core: 'Water', items: ['물', '귀', '신장', '추위'] }
                    },
                    { // Level 2
                        'Wood': { core: 'Wood', items: ['분노', '파랑', '담낭'] },
                        'Fire': { core: 'Fire', items: ['기쁨', '빨강', '소장'] },
                        'Earth': { core: 'Earth', items: ['생각', '노랑', '위장'] },
                        'Metal': { core: 'Metal', items: ['슬픔', '하양', '대장'] },
                        'Water': { core: 'Water', items: ['공포', '검정', '방광'] }
                    },
                    { // Level 3
                        'Wood': { core: 'Wood', items: ['봄', '손톱', '신맛', '동쪽'] },
                        'Fire': { core: 'Fire', items: ['여름', '얼굴', '쓴맛', '남쪽'] },
                        'Earth': { core: 'Earth', items: ['입술', '단맛'] },
                        'Metal': { core: 'Metal', items: ['가을', '체모', '매움', '서쪽'] },
                        'Water': { core: 'Water', items: ['겨울', '모발', '짠맛', '북쪽'] }
                    }
                ]
            }
        };

        let currentLanguage = 'en';

        // Get language from URL parameter
        function getLanguageFromURL() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const lang = urlParams.get('lang');
                if (lang === 'kor' || lang === 'ko' || lang === 'korean') {
                    return 'ko';
                } else if (lang === 'eng' || lang === 'en' || lang === 'english') {
                    return 'en';
                }
            } catch (e) {
                // Silently fail in restricted environments
                console.log('URL parameter reading not available in this environment');
            }
            return 'en'; // default
        }

        // Initialize language from URL
        currentLanguage = getLanguageFromURL();

        function setLanguage(lang) {
            currentLanguage = lang;
            
            // Update URL parameter (only if not in iframe/restricted environment)
            try {
                const url = new URL(window.location);
                if (lang === 'ko') {
                    url.searchParams.set('lang', 'kor');
                } else {
                    url.searchParams.set('lang', 'eng');
                }
                window.history.replaceState({}, '', url);
            } catch (e) {
                // Silently fail in restricted environments (like iframe)
                console.log('URL update not available in this environment');
            }
            
            // Update UI elements
            document.querySelectorAll('[data-translate]').forEach(element => {
                const key = element.getAttribute('data-translate');
                if (LANGUAGES[lang][key]) {
                    element.textContent = LANGUAGES[lang][key];
                }
            });

            // Update language toggle buttons
            const desktopToggle = document.getElementById('language-toggle');
            const mobileToggle = document.getElementById('mobile-language-toggle');
            if (lang === 'en') {
                if (desktopToggle) desktopToggle.textContent = 'Kor';
                if (mobileToggle) mobileToggle.textContent = 'Kor';
            } else {
                if (desktopToggle) desktopToggle.textContent = 'Eng';
                if (mobileToggle) mobileToggle.textContent = 'Eng';
            }

            // Update game data
            updateDataForLevel(level);
            
            // Regenerate next block with new language
            if (nextBlock && nextBlock.type !== 'star') {
                generateNewBlock();
            }
            
            // Update level up subtitle if visible
            updateLevelUpSubtitle();
            
            draw();
        }

        function updateLevelUpSubtitle() {
            const stageText = LANGUAGES[currentLanguage].stage || 'Stage';
            const speedUpText = LANGUAGES[currentLanguage].speed_up || 'Speed Up!';
            
            if (levelUpSubtitle) {
                if (level <= 3) {
                    levelUpSubtitle.textContent = `${stageText} ${level} Start`;
                } else {
                    levelUpSubtitle.textContent = speedUpText;
                }
            }
            
            if (document.getElementById('mobileLevelUpSubtitle')) {
                if (level <= 3) {
                    document.getElementById('mobileLevelUpSubtitle').textContent = `${stageText} ${level} Start`;
                } else {
                    document.getElementById('mobileLevelUpSubtitle').textContent = speedUpText;
                }
            }
        }

        // Detect if mobile
        const isMobile = window.innerWidth <= 768;
        
        // Get elements based on layout
        const canvas = document.getElementById(isMobile ? 'mobileGameCanvas' : 'gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextBlockCanvas = document.getElementById(isMobile ? 'mobileNextBlockCanvas' : 'nextBlockCanvas');
        const nextCtx = nextBlockCanvas.getContext('2d');
        const pixelPersonCanvas = document.getElementById(isMobile ? 'mobilePixelPersonCanvas' : 'pixelPersonCanvas');
        const personCtx = pixelPersonCanvas.getContext('2d');
        const gameContainer = document.getElementById(isMobile ? 'mobile-game-container' : 'game-container');
        const scoreEl = document.getElementById(isMobile ? 'mobileScore' : 'score');
        const levelEl = document.getElementById(isMobile ? 'mobileLevel' : 'level');
        const gameOverScreen = document.getElementById(isMobile ? 'mobileGameOverScreen' : 'gameOverScreen');
        const finalScoreEl = document.getElementById(isMobile ? 'mobileFinalScore' : 'finalScore');
        const restartButton = document.getElementById(isMobile ? 'mobileRestartButton' : 'restartButton');
        const levelUpScreen = document.getElementById(isMobile ? 'mobileLevelUpScreen' : 'levelUpScreen');
        const continueButton = document.getElementById(isMobile ? 'mobileContinueButton' : 'continueButton');
        const levelUpTitle = document.getElementById(isMobile ? 'mobileLevelUpTitle' : 'levelUpTitle');
        const levelUpSubtitle = document.getElementById(isMobile ? 'mobileLevelUpSubtitle' : 'levelUpSubtitle');
        const helpButton = document.getElementById(isMobile ? 'mobile-help-button' : 'help-button');
        const helpModal = document.getElementById(isMobile ? 'mobileHelpModal' : 'helpModal');
        const closeHelpButton = document.getElementById(isMobile ? 'mobileCloseHelpButton' : 'closeHelpButton');
        const pauseScreen = document.getElementById(isMobile ? 'mobilePauseScreen' : 'pauseScreen');
        
        // Touch areas
        const leftTouchArea = document.getElementById(isMobile ? 'mobileLeftTouchArea' : 'leftTouchArea');
        const rightTouchArea = document.getElementById(isMobile ? 'mobileRightTouchArea' : 'rightTouchArea');
        const touchAreasContainer = gameContainer.querySelector('.touch-areas-container');

        const synth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
        const polySynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination();
        const landingSynth = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 } }).toDestination();

        const BLOCK_COLORS = ['#f5f5dc', '#ffe4c4', '#deb887', '#d2b48c'];
        const TEXT_COLOR = '#44403c';
        
        let ALL_ITEMS = [];
        let ITEM_CORE_MAP = {};

        const COLS = 5;
        const ROWS = 8;
        let blockSize;
        let fallingBlock = null;
        let nextBlock = null;
        let stackedBlocks = Array(COLS).fill(0).map(() => []);
        let score = 0;
        let level = 1;
        let fallInterval = 1000;
        let baseFallInterval = 1000;
        let lastUpdateTime = 0;
        let gameRunning = true;
        let blockIdCounter = 0;
        let isLanding = false;
        let isFastDropping = false;

        let personFrame = 0;
        const personFrames = [
             [ // Frame 1
                "  BB  ",
                "  BB  ",
                "   G   ",
                " GGG  ",
                "G G G ",
                " G G  ",
                " G G  ",
            ],
            [ // Frame 2
                "  BB  ",
                "  BB  ",
                "   G   ",
                " GGG  ",
                "G G G ",
                " G G  ",
                "G   G ",
            ]
        ];

        function drawPixelPerson() {
            const pixelSize = isMobile ? 2 : 4;
            personCtx.clearRect(0, 0, pixelPersonCanvas.width, pixelPersonCanvas.height);
            const frame = personFrames[personFrame];
            const colors = { 'B': '#3b82f6', 'G': '#6b7280' }; // Blue, Grey
            
            for (let y = 0; y < frame.length; y++) {
                for (let x = 0; x < frame[y].length; x++) {
                    if (colors[frame[y][x]]) {
                        personCtx.fillStyle = colors[frame[y][x]];
                        personCtx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
            }
            personFrame = (personFrame + 1) % personFrames.length;
        }

        function updateDataForLevel(levelNumber) {
            const currentLangData = LANGUAGES[currentLanguage];
            ALL_ITEMS = [];
            ITEM_CORE_MAP = {};
            
            // 누적 방식: 현재 레벨까지의 모든 데이터를 포함
            for (let i = 0; i < Math.min(levelNumber, currentLangData.levels.length); i++) {
                const levelData = currentLangData.levels[i];
                for (const coreElement in levelData) {
                    for (const item of levelData[coreElement].items) {
                        if (!ITEM_CORE_MAP[item]) {
                            ALL_ITEMS.push(item);
                            ITEM_CORE_MAP[item] = coreElement;
                        }
                    }
                }
            }
        }

        function init() {
            resizeCanvas();
            score = 0;
            level = 1;
            updateDataForLevel(1);
            baseFallInterval = 1000;
            fallInterval = 1000;
            stackedBlocks = Array(COLS).fill(0).map(() => []);
            fallingBlock = null;
            nextBlock = null;
            gameRunning = true;
            isLanding = false;
            isFastDropping = false;
            scoreEl.textContent = score;
            levelEl.textContent = level;
            gameOverScreen.classList.add('hidden');
            levelUpScreen.classList.add('hidden');
            pauseScreen.classList.add('hidden');
            if (isMobile) touchAreasContainer.style.display = 'block';
            
            generateNewBlock();
            spawnFallingBlock();

            lastUpdateTime = performance.now();
            requestAnimationFrame(gameLoop);
            setInterval(drawPixelPerson, 300);
        }

        function resizeCanvas() {
            const containerWidth = gameContainer.clientWidth;
            const containerHeight = gameContainer.clientHeight;
            canvas.width = containerWidth;
            canvas.height = containerHeight;
            blockSize = canvas.width / COLS;
            
            if (isMobile) {
                nextBlockCanvas.width = blockSize * 0.8;
                nextBlockCanvas.height = blockSize * 0.8;
                pixelPersonCanvas.width = 12;
                pixelPersonCanvas.height = 14;
            } else {
                nextBlockCanvas.width = blockSize;
                nextBlockCanvas.height = blockSize;
                pixelPersonCanvas.width = 24;
                pixelPersonCanvas.height = 28;
            }
        }
        
        function moveFallingBlock(direction) {
            if (!gameRunning || !fallingBlock) return;
            if (direction === 'left') {
                if (fallingBlock.col > 0) fallingBlock.col--;
            } else if (direction === 'right') {
                if (fallingBlock.col < COLS - 1) fallingBlock.col++;
            }
            fallingBlock.x = fallingBlock.col * blockSize;
        }

        function startFastDrop() {
            if (!gameRunning || !fallingBlock) return;
            isFastDropping = true;
            fallInterval = 50;
        }

        function stopFastDrop() {
            isFastDropping = false;
            fallInterval = baseFallInterval;
        }

        function generateNewBlock() {
            const randomChance = 30 + Math.random() * 40; // Random between 30 and 70
            if (Math.random() < 1 / randomChance) {
                nextBlock = {
                    id: blockIdCounter++,
                    name: '',
                    type: 'star',
                    color: '#F7F3EF', // Same as background
                    textColor: '#000000',
                };
                return;
            }

            if (ALL_ITEMS.length === 0) return null;
            const randomItemName = ALL_ITEMS[Math.floor(Math.random() * ALL_ITEMS.length)];
            const coreElement = ITEM_CORE_MAP[randomItemName];
            const randomColor = BLOCK_COLORS[Math.floor(Math.random() * BLOCK_COLORS.length)];
            
            nextBlock = {
                id: blockIdCounter++,
                name: randomItemName,
                core: coreElement,
                color: randomColor,
                textColor: TEXT_COLOR,
            };
        }

        function spawnFallingBlock() {
            fallingBlock = {
                ...nextBlock,
                col: Math.floor(COLS / 2),
                x: Math.floor(COLS / 2) * blockSize,
                y: -blockSize,
            };
            generateNewBlock();
        }

        function drawBlock(block, x, y, size, targetCtx = ctx) {
            const cornerRadius = size * 0.2;
            const strokeColor = '#854d0e';
            const strokeWidth = 2;
            
            const padding = strokeWidth / 2;
            const drawX = x + padding;
            const drawY = y + padding;
            const drawSize = size - (padding * 2);

            targetCtx.fillStyle = block.color;
            targetCtx.strokeStyle = strokeColor;
            targetCtx.lineWidth = strokeWidth;

            targetCtx.beginPath();
            targetCtx.moveTo(drawX + cornerRadius, drawY);
            targetCtx.lineTo(drawX + drawSize - cornerRadius, drawY);
            targetCtx.arcTo(drawX + drawSize, drawY, drawX + drawSize, drawY + cornerRadius, cornerRadius);
            targetCtx.lineTo(drawX + drawSize, drawY + drawSize - cornerRadius);
            targetCtx.arcTo(drawX + drawSize, drawY + drawSize, drawX + drawSize - cornerRadius, drawY + drawSize, cornerRadius);
            targetCtx.lineTo(drawX + cornerRadius, drawY + drawSize);
            targetCtx.arcTo(drawX, drawY + drawSize, drawX, drawY + drawSize - cornerRadius, cornerRadius);
            targetCtx.lineTo(drawX, drawY + cornerRadius);
            targetCtx.arcTo(drawX, drawY, drawX + cornerRadius, drawY, cornerRadius);
            targetCtx.closePath();
            
            targetCtx.fill();
            targetCtx.stroke();
            
            if (block.type === 'star') {
                const sparkleSize = size * 0.08;
                const sparkleColor = `rgba(220, 180, 0, ${0.5 + Math.sin(Date.now() / 150) * 0.5})`;
                targetCtx.fillStyle = sparkleColor;
                
                const positions = [
                    [-0.2, -0.2], [0.2, -0.15], [-0.1, 0.25]
                ];
                positions.forEach(([px, py]) => {
                    targetCtx.beginPath();
                    targetCtx.arc(x + size / 2 + size * px, y + size / 2 + size * py, sparkleSize, 0, Math.PI * 2);
                    targetCtx.fill();
                });
            } else {
                targetCtx.fillStyle = block.textColor;
                // Increased font size for both languages
                let fontSize;
                if (currentLanguage === 'en') {
                    fontSize = size * (isMobile ? 0.24 : 0.26);
                } else {
                    fontSize = size * (isMobile ? 0.20 : 0.22);
                }
                targetCtx.font = `bold ${fontSize}px 'Noto Sans'`;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                
                if (block.name.includes('\n')) {
                    const lines = block.name.split('\n');
                    targetCtx.fillText(lines[0], x + size / 2, y + size / 2 - fontSize / 1.5);
                    targetCtx.fillText(lines[1], x + size / 2, y + size / 2 + fontSize / 1.5);
                } else {
                    targetCtx.fillText(block.name, x + size / 2, y + size / 2 + 1);
                }
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#D7CCC8';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(1, 0);
            ctx.lineTo(1, canvas.height);
            ctx.moveTo(canvas.width - 1, 0);
            ctx.lineTo(canvas.width - 1, canvas.height);
            ctx.stroke();

            stackedBlocks.forEach((col, colIndex) => {
                col.forEach((block, rowIndex) => {
                    const y = canvas.height - (rowIndex + 1) * blockSize;
                    drawBlock(block, colIndex * blockSize, y, blockSize);
                });
            });
            if (fallingBlock) {
                drawBlock(fallingBlock, fallingBlock.x, fallingBlock.y, blockSize);
            }

            nextCtx.clearRect(0, 0, nextBlockCanvas.width, nextBlockCanvas.height);
            if(nextBlock) {
                const previewSize = isMobile ? blockSize * 0.8 : blockSize;
                const x = (nextBlockCanvas.width - previewSize) / 2;
                const y = (nextBlockCanvas.height - previewSize) / 2;
                drawBlock(nextBlock, x, y, previewSize, nextCtx);
            }
        }

        function update(timestamp) {
            if (!gameRunning || fallingBlock === null) return;
            const deltaTime = timestamp - lastUpdateTime;
            lastUpdateTime = timestamp;

            const fallSpeed = blockSize / fallInterval; 
            fallingBlock.y += fallSpeed * deltaTime;

            const col = fallingBlock.col;
            const stackHeight = stackedBlocks[col].length * blockSize;
            const landingY = canvas.height - stackHeight;

            if (fallingBlock.y + blockSize >= landingY) {
                if (!isLanding) {
                    isLanding = true;
                    const blockToLand = fallingBlock;
                    fallingBlock = null;
                    handleLanding(blockToLand);
                }
            }
        }
        
        function getBlock(c, r) {
            if (c < 0 || c >= COLS || r < 0 || !stackedBlocks[c] || r >= stackedBlocks[c].length) return null;
            return stackedBlocks[c][r];
        }

        function findMatches() {
            const components = [];
            const visited = new Set();

            for (let c = 0; c < COLS; c++) {
                for (let r = 0; r < stackedBlocks[c].length; r++) {
                    const startBlock = getBlock(c, r);
                    if (!startBlock || startBlock.type === 'star' || visited.has(startBlock.id)) continue;

                    const component = [];
                    const queue = [[c, r]];
                    const componentVisited = new Set([startBlock.id]);
                    visited.add(startBlock.id);

                    while (queue.length > 0) {
                        const [currC, currR] = queue.shift();
                        const currentBlock = getBlock(currC, currR);
                        component.push(currentBlock);

                        const neighbors = [[currC, currR + 1], [currC, currR - 1], [currC + 1, currR], [currC - 1, currR]];

                        for (const [nextC, nextR] of neighbors) {
                            const neighborBlock = getBlock(nextC, nextR);
                            if (neighborBlock && !componentVisited.has(neighborBlock.id) && neighborBlock.core === startBlock.core) {
                                componentVisited.add(neighborBlock.id);
                                visited.add(neighborBlock.id);
                                queue.push([nextC, nextR]);
                            }
                        }
                    }

                    if (component.length >= 3) {
                       components.push(component);
                    }
                }
            }
            return components;
        }

        async function processMatchesAndChains() {
            while (true) {
                const componentsToRemove = findMatches();
                if (componentsToRemove.length === 0) break;

                const toRemove = new Set();
                const now = Tone.now();
                let timeOffset = 0;

                for(const component of componentsToRemove) {
                    if (component.length >= 4) {
                        score += component.length * 20;
                        const notes = ["C5", "D5", "E5", "G5", "A5"];
                        notes.forEach((note, i) => {
                            polySynth.triggerAttackRelease(note, "16n", now + timeOffset + i * 0.08);
                        });
                        timeOffset += 0.5;
                    } else {
                        score += component.length * 10;
                        synth.triggerAttackRelease("C5", "16n", now + timeOffset);
                        synth.triggerAttackRelease("E5", "16n", now + timeOffset + 0.1);
                        synth.triggerAttackRelease("G5", "16n", now + timeOffset + 0.2);
                        timeOffset += 0.3;
                    }
                    component.forEach(block => toRemove.add(block.id));
                }

                scoreEl.textContent = score;
                
                for (let c = 0; c < COLS; c++) {
                    stackedBlocks[c] = stackedBlocks[c].filter(block => !toRemove.has(block.id));
                }
                
                draw();
                await new Promise(resolve => setTimeout(resolve, 250));
            }
        }

        async function handleLanding(landedBlock) {
            if (!landedBlock) {
                isLanding = false;
                return;
            }
            
            landingSynth.triggerAttackRelease("C2", "8n");
            stopFastDrop();

            const col = landedBlock.col;
            landedBlock.y = canvas.height - (stackedBlocks[col].length + 1) * blockSize;
            stackedBlocks[col].push(landedBlock);
            
            if (landedBlock.type === 'star') {
                const r = stackedBlocks[col].length - 1;
                const toRemove = new Set([landedBlock.id]);
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const neighbor = getBlock(col + i, r + j);
                        if (neighbor) {
                            toRemove.add(neighbor.id);
                        }
                    }
                }
                score += toRemove.size * 15;
                scoreEl.textContent = score;
                polySynth.triggerAttackRelease(["C4", "E4", "G4", "C5"], "8n");

                for (let c = 0; c < COLS; c++) {
                    stackedBlocks[c] = stackedBlocks[c].filter(block => !toRemove.has(block.id));
                }
            }
            
            draw();

            await processMatchesAndChains();
            checkLevelUp();

            for (let c = 0; c < COLS; c++) {
                if (stackedBlocks[c].length >= ROWS) {
                    gameOver();
                    return;
                }
            }

            if (gameRunning) {
                spawnFallingBlock();
            }
            isLanding = false;
        }

        function showLevelUpScreen() {
            // 레벨 4까지만 레벨업 창 표시
            if (level <= 4) {
                gameRunning = false;
                if (isMobile) touchAreasContainer.style.display = 'none';
                levelUpScreen.classList.remove('hidden');
                levelUpScreen.classList.add('flex');
                levelUpTitle.textContent = LANGUAGES[currentLanguage].level_up;
                updateLevelUpSubtitle();
            }
            
            // 레벨과 데이터는 항상 업데이트
            levelEl.textContent = level;
            updateDataForLevel(level);
            
            // 속도 증가 로직
            if (level >= 3 && level <= 4) {
                baseFallInterval = Math.max(100, baseFallInterval * 0.8); // 20% 빨라짐 (80%로 곱함)
            } else if (level >= 5) {
                baseFallInterval = Math.max(50, baseFallInterval * 0.9); // 10% 빨라짐 (90%로 곱함)
            } else {
                baseFallInterval = Math.max(150, baseFallInterval * 0.9);
            }
            fallInterval = baseFallInterval;
        }

        function checkLevelUp() {
            let leveledUp = false;
            if (level === 1 && score >= 100) {
                level = 2;
                leveledUp = true;
            } else if (level === 2 && score >= 250) {
                level = 3;
                leveledUp = true;
            } else if (level >= 3) {
                // 레벨 3부터는 100점마다 레벨업
                const nextLevelScore = 250 + (level - 2) * 100;
                if (score >= nextLevelScore) {
                    level++;
                    leveledUp = true;
                }
            }

            if (leveledUp) {
                showLevelUpScreen();
                // 레벨 5부터는 창을 표시하지 않고 게임 계속 진행
                if (level > 4) {
                    resumeGame();
                }
            }
        }

        function gameOver() {
            gameRunning = false;
            if (isMobile) touchAreasContainer.style.display = 'none';
            finalScoreEl.textContent = score;
            gameOverScreen.classList.remove('hidden');
            gameOverScreen.classList.add('flex');
        }

        function togglePause() {
            if (helpModal.classList.contains('flex')) return;
            gameRunning = !gameRunning;
            if (gameRunning) {
                if (isMobile) touchAreasContainer.style.display = 'block';
                pauseScreen.classList.add('hidden');
                pauseScreen.classList.remove('flex');
                lastUpdateTime = performance.now();
                requestAnimationFrame(gameLoop);
            } else {
                if (isMobile) touchAreasContainer.style.display = 'none';
                pauseScreen.classList.remove('hidden');
                pauseScreen.classList.add('flex');
            }
        }

        function gameLoop(timestamp) {
            if (!gameRunning) return;
            update(timestamp);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function resumeGame() {
            levelUpScreen.classList.add('hidden');
            levelUpScreen.classList.remove('flex');
            gameRunning = true;
            if (isMobile) touchAreasContainer.style.display = 'block';
            fallingBlock = null;
            spawnFallingBlock();
            lastUpdateTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function startAudioContext() {
            if (Tone.context.state !== 'running') {
                Tone.start().then(() => {
                    console.log('Audio context started successfully');
                }).catch(err => {
                    console.log('Audio context failed to start:', err);
                });
            }
        }
        
        // Start audio on first user interaction
        function enableAudio() {
            startAudioContext();
            // Remove listeners after first activation
            document.removeEventListener('click', enableAudio);
            document.removeEventListener('touchstart', enableAudio);
            document.removeEventListener('keydown', enableAudio);
        }
        
        document.addEventListener('click', enableAudio);
        document.addEventListener('touchstart', enableAudio);
        document.addEventListener('keydown', enableAudio);

        // Desktop keyboard controls
        window.addEventListener('keydown', (e) => {
            if (e.key === ' ') { 
                e.preventDefault();
                togglePause();
                return;
            }
            if (!gameRunning) return;
            if (e.key === 'ArrowLeft') moveFallingBlock('left');
            else if (e.key === 'ArrowRight') moveFallingBlock('right');
            else if (e.key === 'ArrowDown') {
                 if(fallingBlock) startFastDrop();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowDown') {
                stopFastDrop();
            }
        });

        // Touch controls for mobile
        function addTouchEventListeners(element, onStart, onEnd) {
            element.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (onStart) onStart();
            }, { passive: false });
            
            element.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (onEnd) onEnd();
            }, { passive: false });
            
            element.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                if (onEnd) onEnd();
            }, { passive: false });
        }

        // Add touch listeners for left/right movement
        addTouchEventListeners(leftTouchArea, () => moveFallingBlock('left'));
        addTouchEventListeners(rightTouchArea, () => moveFallingBlock('right'));

        // Add new listeners for two-finger fast drop on the whole touch container
        if (isMobile) {
            touchAreasContainer.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    startFastDrop();
                }
            }, { passive: false });

            touchAreasContainer.addEventListener('touchend', (e) => {
                if (e.touches.length < 2 && isFastDropping) {
                    stopFastDrop();
                }
            });
            
            touchAreasContainer.addEventListener('touchcancel', (e) => {
                if (isFastDropping) {
                    stopFastDrop();
                }
            });
        }

        // Language switching event listeners
        document.getElementById('language-toggle').addEventListener('click', () => {
            setLanguage(currentLanguage === 'en' ? 'ko' : 'en');
        });
        
        document.getElementById('mobile-language-toggle').addEventListener('click', () => {
            setLanguage(currentLanguage === 'en' ? 'ko' : 'en');
        });

        // Button event listeners
        restartButton.addEventListener('click', init);
        continueButton.addEventListener('click', resumeGame);
        
        helpButton.addEventListener('click', () => {
            if (gameRunning) {
                gameRunning = false;
                if (isMobile) touchAreasContainer.style.display = 'none';
                helpModal.classList.remove('hidden');
                helpModal.classList.add('flex');
            }
        });
        
        closeHelpButton.addEventListener('click', () => {
            helpModal.classList.add('hidden');
            helpModal.classList.remove('flex');
            if (!pauseScreen.classList.contains('flex')) {
                gameRunning = true;
                if (isMobile) touchAreasContainer.style.display = 'block';
                lastUpdateTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        });
        
        window.addEventListener('resize', () => {
            const newIsMobile = window.innerWidth <= 768;
            if (newIsMobile !== isMobile) {
                location.reload();
            } else {
                resizeCanvas();
            }
        });
        
        // Initialize the game
        // Set initial language from URL before initializing
        setLanguage(currentLanguage);
        init();
    </script>
</body>
</html>
